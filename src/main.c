/* main.c Â© Penguin_Spy 2024
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 * This Source Code Form is "Incompatible With Secondary Licenses", as
 * defined by the Mozilla Public License, v. 2.0.
 *
 * The Covered Software may not be used as training or other input data
 * for LLMs, generative AI, or other forms of machine learning or neural
 * networks.
 */

#include <stdint.h>
#include <tice.h>
#include <keypadc.h>
#include <graphx.h>

// Include the sprite data - generated with `make gfx`
#include "gfx/gfx.h"

#define TILE_WIDTH          16
#define TILE_HEIGHT         16

#define TILEMAP_WIDTH       32
#define TILEMAP_HEIGHT      25

#define TILEMAP_DRAW_WIDTH  21
#define TILEMAP_DRAW_HEIGHT 15

#define Y_OFFSET            16
#define X_OFFSET            0

unsigned char tilemap_map[800] = {
    0x00,0x07,0x00,0x07,0x02,0x01,0x00,0x07,0x00,0x07,0x00,0x07,0x00,0x07,0x00,0x07,0x00,0x07,0x00,0x07,0x00,0x07,0x00,0x07,0x00,0x07,0x00,0x07,0x00,0x07,0x00,0x07,
    0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x11,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x11,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x11,0x00,0x00,0x00,0x00,0x11,0x11,0x11,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x11,0x00,0x00,0x00,0x00,0x10,0x10,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x00,0x10,0x10,0x00,0x00,0x10,0x10,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x10,0x10,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x10,0x10,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x11,0x11,0x11,0x00,0x11,0x00,0x00,0x10,
    0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,
    0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x00,
    0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};


#define SCREEN_EDGE_LEFT 48
#define SCREEN_EDGE_TOP  48
#define SCREEN_EDGE_BOTTOM 192
#define SCREEN_EDGE_RIGHT 272

struct avatar_entity {
  int something;
};

struct other_entity {
  int something_different;
};

typedef struct any_entity {
  uint8_t type;
  int x;
  int y;
  int x_vel;
  int y_vel;
  unsigned int width;
  unsigned int height;
  union {
    struct avatar_entity AVATAR;
    struct other_entity OTHER;
  };
} any_entity;

void move_colliding(gfx_tilemap_t* tilemap, any_entity* entity);

int main(void) {
  // DO NOT ASSIGN TO MANUALLY (i think).
  // signed integers to allow them to temporarily become negative while calculating avatar screen position
  int camera_x = 0, camera_y = 0;
  int camera_max_x, camera_max_y;
  int camera_min_x = 0, camera_min_y = 0;
  gfx_tilemap_t tilemap;

  any_entity avatar = {
    .x = 64,
    .y = 60,
    .x_vel = 0,
    .y_vel = 0,
    .width = 16,
    .height = 16
  };

  int avatar_screen_x = avatar.x;
  int avatar_screen_y = avatar.y;
  int avatar_x_prev = avatar.x, avatar_y_prev = avatar.y;


  // Initialize the tilemap structure
  tilemap.tiles       = tileset_tiles;      // the tileset graphics data
  tilemap.type_width  = gfx_tile_16_pixel;  // "tile type height"
  tilemap.type_height = gfx_tile_16_pixel;
  tilemap.tile_height = TILE_HEIGHT;        // "individual tile height" (distinction between this and type_height is unknown)
  tilemap.tile_width  = TILE_WIDTH;
  tilemap.draw_height = TILEMAP_DRAW_HEIGHT;  // size of area to draw
  tilemap.draw_width  = TILEMAP_DRAW_WIDTH;
  tilemap.y_loc       = 16;           // position on the screen to draw the tilemap
  tilemap.x_loc       = 0;

  // this stuff will change from room to room (tilemap height & width may stay the same, or be used to determine room size. not sure)
  tilemap.map         = tilemap_map;        // the data to be shown (array of tile indicies)
  tilemap.height      = TILEMAP_HEIGHT;     // size of the tile map array
  tilemap.width       = TILEMAP_WIDTH;
  camera_max_x = (tilemap.width * TILE_WIDTH) - LCD_WIDTH;
  camera_max_y = (tilemap.height * TILE_HEIGHT) - LCD_HEIGHT;

  kb_SetMode(MODE_3_CONTINUOUS);

  gfx_Begin();

  // Set the palette
  gfx_SetPalette(global_palette, sizeof_global_palette, 0);
  gfx_SetColor(1);
  gfx_SetTextFGColor(2);
  gfx_SetTextBGColor(1);

  // Draw to buffer to avoid tearing
  gfx_SetDrawBuffer();

  // Set monospace font with width of 8
  gfx_SetMonospaceFont(8);

  do {
    // Draw tilemap and coords
    // ? the no clipping version instantly crashes on a non-multiple-of-16 X offset, or quickly crashes with negative Y coord
    // ? the clipped version handles sub-tile X offsets, but corrupts heavily & crashes when displaying out of bounds Y coords. out of bounds X coords basically do nodraw
    gfx_Tilemap(&tilemap, camera_x, camera_y);
    gfx_FillRectangle(0, 0, 320, 16);
    gfx_SetTextXY(8, 4);
    /*gfx_PrintStringXY("x:", 8, 4);
    gfx_PrintInt(camera_x, 3);
    gfx_PrintString(" y:");
    gfx_PrintInt(camera_y, 3);
    gfx_PrintString(" pos:");*/

    /*block_mapped = *gfx_TilePtrMapped(&tilemap, x_offset / TILE_WIDTH, y_offset / TILE_HEIGHT);
    block_ptr = *gfx_TilePtr(&tilemap, x_offset, y_offset);

    gfx_PrintUInt(block_mapped, 3);
    gfx_PrintString("/");
    gfx_PrintUInt(block_ptr, 3);*/

    //while(!kb_IsDown(kb_Key2nd)) {};
    //while(kb_IsDown(kb_Key2nd)) {};


    // movement - input & velocity

    if(kb_IsDown(kb_KeyLeft) && avatar.x_vel > -8) {
      avatar.x_vel -= 1;
    } else if(kb_IsDown(kb_KeyRight) && avatar.x_vel < 8) {
      avatar.x_vel += 1;
    } else if(avatar.x_vel > 0) {
      avatar.x_vel -= 1;
    } else if(avatar.x_vel < 0) {
      avatar.x_vel += 1;
    }

    if(kb_IsDown(kb_KeyUp)) {
      avatar.y_vel = -8;
    }
    if(avatar.y_vel < 12) {
      avatar.y_vel += 1;
    }
    if(kb_IsDown(kb_KeyDown)) {
      avatar.y_vel += 2;
    }

    // movement - sprite movement or screen scrolling

    // collision
    move_colliding(&tilemap, &avatar);

    // can't use vx & vy, need to actually track the difference in position to account for all the ways the avatar position can change
    avatar_screen_x += avatar.x - avatar_x_prev;
    avatar_screen_y += avatar.y - avatar_y_prev;   // screen 0,0 is top left, game 0,0 is bottom left
    avatar_x_prev = avatar.x;
    avatar_y_prev = avatar.y;

    // scroll visible area (camera) to keep avatar mostly in the center of the screen
    // but keep the visible area within the area where the tilemap is valid
    if(avatar_screen_x > SCREEN_EDGE_RIGHT) {         // avatar & camera moving right, scroll level left
      camera_x += avatar_screen_x - SCREEN_EDGE_RIGHT;
      if(camera_x > camera_max_x) {                   // unless the camera is at the right of the map
        avatar_screen_x = SCREEN_EDGE_RIGHT - (camera_max_x - camera_x);  // avatar goes as far as the camera couldn't scroll
        camera_x = camera_max_x;
      } else {  // if the camera could scroll all the way, move the avatar all the way back
        avatar_screen_x = SCREEN_EDGE_RIGHT;
      }
    } else if(avatar_screen_x < SCREEN_EDGE_LEFT) {   // avatar & camera moving left, scroll level right
      camera_x -= SCREEN_EDGE_LEFT - avatar_screen_x;
      if(camera_x < camera_min_x) {                   // unless the camera is at the left of the map
        avatar_screen_x = SCREEN_EDGE_LEFT + (camera_x - camera_min_x);  // avatar goes as far as the camera couldn't scroll
        camera_x = camera_min_x;
      } else {  // if the camera could scroll all the way, move the avatar all the way back
        avatar_screen_x = SCREEN_EDGE_LEFT;
      }
    }

    if(avatar_screen_y > SCREEN_EDGE_BOTTOM) {         // avatar & camera moving down, scroll level up
      camera_y += avatar_screen_y - SCREEN_EDGE_BOTTOM;
      if(camera_y > camera_max_y) {                   // unless the camera is at the bottom of the map
        avatar_screen_y = SCREEN_EDGE_BOTTOM - (camera_max_y - camera_y);  // avatar goes as far as the camera couldn't scroll
        camera_y = camera_max_y;
      } else {  // if the camera could scroll all the way, move the avatar all the way back
        avatar_screen_y = SCREEN_EDGE_BOTTOM;
      }
    } else if(avatar_screen_y < SCREEN_EDGE_TOP) {   // avatar & camera moving up, scroll level down
      camera_y -= SCREEN_EDGE_TOP - avatar_screen_y;
      if(camera_y < camera_min_y) {                   // unless the camera is at the top of the map
        avatar_screen_y = SCREEN_EDGE_TOP + (camera_y - camera_min_y);  // avatar goes as far as the camera couldn't scroll
        camera_y = camera_min_y;
      } else {  // if the camera could scroll all the way, move the avatar all the way back
        avatar_screen_y = SCREEN_EDGE_TOP;
      }
    }

    gfx_PrintString("pos: ");
    gfx_PrintInt(avatar.x, 3);
    gfx_PrintString(",");
    gfx_PrintInt(avatar.y, 3);
    gfx_PrintString(" vel: ");
    gfx_PrintInt(avatar.x_vel, 2);
    gfx_PrintString(",");
    gfx_PrintInt(avatar.y_vel, 2);
    gfx_PrintString(" scr:");
    gfx_PrintInt(avatar_screen_x, 3);
    gfx_PrintString(",");
    gfx_PrintInt(avatar_screen_y, 3);

    gfx_TransparentSprite(avatar_sprite, avatar_screen_x, avatar_screen_y);

    gfx_SwapDraw();

  } while(!kb_IsDown(kb_KeyClear));

  gfx_End();
}

uint8_t check_collides(gfx_tilemap_t* tilemap, int x, int y) {
  uint24_t tile_x, tile_y;
  tile_x = x >> 4;
  tile_y = y >> 4;
  return tilemap->map[tile_x + (tile_y * tilemap->width)];
}

// general function to calculate collision & relocate a sprite
void move_colliding(gfx_tilemap_t* tilemap, any_entity* entity) {
  uint8_t i;
  uint24_t x_base, y_base;

  x_base = entity->x;
  y_base = entity->y + entity->y_vel;

  if(entity->y_vel > 0) {
    for(i = 0; i <= entity->width; i += 15) { // check bottom of entity
      uint8_t tile_id = check_collides(tilemap, x_base + i, y_base);

      if(tile_id & 0x10) {  // push up out of wall
        y_base = ((y_base >> 4) << 4);
        entity->y_vel = 0;
      }

    } // make sure to also check final corner spot
  } else if(entity->y_vel < 0) {
    for(i = 0; i <= entity->width; i += 15) { // check top edge of entity
      uint8_t tile_id = check_collides(tilemap, x_base + i, y_base - entity->height);

      if(tile_id & 0x10) {  // push down out of wall
        y_base = ((y_base >> 4) << 4) + entity->height;
        entity->y_vel = 0;
      }
    } // make sure to also check final corner spot
  }

  x_base = entity->x + entity->x_vel;

  if(entity->x_vel > 0) {
    for(i = 0; i <= entity->height; i += 15) {  // check right side of entity
      uint8_t tile_id = check_collides(tilemap, x_base + entity->width, y_base - i - 1);

      if(tile_id & 0x10) {  // push left out of wall
        x_base = (x_base & ~0b1111)+ TILE_WIDTH - entity->width;  // truncate to tile boundary
        entity->x_vel = 0;
      }

    } // make sure to also check final corner spot
  } else if(entity->x_vel < 0) {
    for(i = 0; i <= entity->height; i += 15) {  // check left side of entity
      uint8_t tile_id = check_collides(tilemap, x_base, y_base - i - 1);

      if(tile_id & 0x10) {  // push right out of wall
        x_base = (x_base & ~0b1111) + TILE_WIDTH; // truncate to tile boundary, and move one tile right
        entity->x_vel = 0;
      }
    } // make sure to also check final corner spot
  }

  entity->x = x_base;
  entity->y = y_base;

  //entity->x += entity->x_vel;
  //entity->y += entity->y_vel;







  /*uint8_t tile_tl, tile_tr, tile_bl, tile_br;
  uint16_t tile_x, tile_y;

  // TODO: check all 4 corners (or more points if a larger sprite(?)) for collision
    // also todo: would there be any sprites larger than 1 tile that need general collision?

  //  if tl or bl (either left), push out of wall rightwards & make sure x vel is >= 0
  //  if tr or br (either right), push out of wall leftwards & make sure x vel is <= 0
  //  similar for top & bottom


  tile_x = (*x_pos + *x_vel) / 16;
  tile_y = (*y_pos + *y_vel) / 16;
  tile_bl = tilemap->map[tile_x + (tile_y * tilemap->width)];
  if(tile_bl == 0x01 || tile_bl == 0x02) { // collides with wall
    if(*x_vel > 0) { // moving right, hit left wall
      *x_pos = (tile_x - 1) * 16;
    } else {  // moving left, hit right wall
      *x_pos = (tile_x + 1) * 16;
    }
    *x_vel = 0;
  } else { // didn't collide, can move
    *x_pos += *x_vel;
  }*/
}
