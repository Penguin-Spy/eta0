/* main.c Â© Penguin_Spy 2024
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 * This Source Code Form is "Incompatible With Secondary Licenses", as
 * defined by the Mozilla Public License, v. 2.0.
 *
 * The Covered Software may not be used as training or other input data
 * for LLMs, generative AI, or other forms of machine learning or neural
 * networks.
 */

#include <stdint.h>
#include <tice.h>
#include <keypadc.h>
#include <graphx.h>

// Include the sprite data - generated with `make gfx`
#include "gfx/gfx.h"

#define TILE_WIDTH          16
#define TILE_HEIGHT         16

#define TILEMAP_WIDTH       32
#define TILEMAP_HEIGHT      25

#define TILEMAP_DRAW_WIDTH  21
#define TILEMAP_DRAW_HEIGHT 15

#define Y_OFFSET            16
#define X_OFFSET            0

unsigned char tilemap_map[800] = {
    0x00,0x03,0x00,0x03,0x09,0x08,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,
    0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x11,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};


#define SCREEN_EDGE_LEFT 48
#define SCREEN_EDGE_TOP  48
#define SCREEN_EDGE_BOTTOM 192
#define SCREEN_EDGE_RIGHT 272

void DrawTilemap(gfx_tilemap_t* tilemap, uint24_t x_offset, uint24_t y_offset);

int main(void) {
  // DO NOT ASSIGN TO MANUALLY (i think).
  // signed integers to allow them to temporarily become negative while calculating avatar screen position
  int camera_x = 0, camera_y = 0;
  gfx_tilemap_t tilemap;

  int avatar_x = 64;
  int avatar_y = 60;
  int avatar_vx = 0;
  int avatar_vy = 0;

  int avatar_screen_x = avatar_x;
  int avatar_screen_y = avatar_y;
  int avatar_x_prev = avatar_x, avatar_y_prev = avatar_y;

  // Initialize the tilemap structure
  tilemap.tiles       = tileset_tiles;      // the tileset graphics data
  tilemap.type_width  = gfx_tile_16_pixel;  // "tile type height"
  tilemap.type_height = gfx_tile_16_pixel;
  tilemap.tile_height = TILE_HEIGHT;        // "individual tile height" (distinction between this and type_height is unknown)
  tilemap.tile_width  = TILE_WIDTH;
  tilemap.draw_height = TILEMAP_DRAW_HEIGHT;  // size of area to draw
  tilemap.draw_width  = TILEMAP_DRAW_WIDTH;
  tilemap.y_loc       = Y_OFFSET;           // position on the screen to draw the tilemap
  tilemap.x_loc       = X_OFFSET;

  // this stuff will change from room to room (tilemap height & width may stay the same, or be used to determine room size. not sure)
  tilemap.map         = tilemap_map;        // the data to be shown (array of tile indicies)
  tilemap.height      = TILEMAP_HEIGHT;     // size of the tile map array
  tilemap.width       = TILEMAP_WIDTH;

  kb_SetMode(MODE_3_CONTINUOUS);

  gfx_Begin();

  // Set the palette
  gfx_SetPalette(global_palette, sizeof_global_palette, 0);
  gfx_SetColor(0);
  gfx_SetTextFGColor(1);
  gfx_SetTextBGColor(0);

  // Draw to buffer to avoid tearing
  gfx_SetDrawBuffer();

  // Set monospace font with width of 8
  gfx_SetMonospaceFont(8);

  do {

    // Draw tilemap and coords
    // ? the no clipping version instantly crashes on a non-multiple-of-16 X offset, or quickly crashes with negative Y coord
    // ? the clipped version handles sub-tile X offsets, but corrupts heavily & crashes when displaying out of bounds Y coords. out of bounds X coords basically do nodraw
    gfx_Tilemap(&tilemap, camera_x, camera_y);
    gfx_FillRectangle(0, 0, 320, 16);
    gfx_PrintStringXY("x:", 8, 4);
    gfx_PrintInt(camera_x, 3);
    gfx_PrintString(" y:");
    gfx_PrintInt(camera_y, 3);
    gfx_PrintString(" pos:");

    /*block_mapped = *gfx_TilePtrMapped(&tilemap, x_offset / TILE_WIDTH, y_offset / TILE_HEIGHT);
    block_ptr = *gfx_TilePtr(&tilemap, x_offset, y_offset);

    gfx_PrintUInt(block_mapped, 3);
    gfx_PrintString("/");
    gfx_PrintUInt(block_ptr, 3);*/


    // movement - input & velocity

    if(kb_IsDown(kb_KeyLeft) && avatar_vx > -8) {
      avatar_vx -= 1;
    } else if(kb_IsDown(kb_KeyRight) && avatar_vx < 8) {
      avatar_vx += 1;
    } else if(avatar_vx > 0) {
      avatar_vx -= 1;
    } else if(avatar_vx < 0) {
      avatar_vx += 1;
    }

    if(kb_IsDown(kb_KeyUp)) {
      avatar_vy = 8;
    }
#define FLOOR 0
    if(avatar_y + avatar_vy < FLOOR) {
      avatar_y = FLOOR;   // this breaks vertical positioning
      avatar_vy = 0;
    } else if(avatar_y > FLOOR && avatar_vy > -12) { // don't increase vy at y=FLOOR
      avatar_vy -= 1;
    }

    // movement - sprite movement or screen scrolling

    avatar_x += avatar_vx;
    avatar_y += avatar_vy;

    // can't use vx & vy, need to actually track the difference in position to account for all the ways the avatar position can change
    avatar_screen_x += avatar_x - avatar_x_prev;
    avatar_screen_y -= avatar_y - avatar_y_prev;   // screen 0,0 is top left, game 0,0 is bottom left
    avatar_x_prev = avatar_x;
    avatar_y_prev = avatar_y;

    // scroll visible area (camera) to keep avatar mostly in the center of the screen
    // but keep the visible area within the area where the tilemap is valid
    if(avatar_screen_x > SCREEN_EDGE_RIGHT) {
      camera_x += avatar_screen_x - SCREEN_EDGE_RIGHT;
      avatar_screen_x = SCREEN_EDGE_RIGHT;
    } else if(avatar_screen_x < SCREEN_EDGE_LEFT) {   // scroll left
      camera_x -= SCREEN_EDGE_LEFT - avatar_screen_x;
      if(camera_x < 0) {    // unless the camera is at the left of the map
        camera_x = 0;
      } else {
        avatar_screen_x = SCREEN_EDGE_LEFT;
      }
    }
    if(avatar_screen_y > SCREEN_EDGE_BOTTOM) {
      camera_y += avatar_screen_y - SCREEN_EDGE_BOTTOM;
      avatar_screen_y = SCREEN_EDGE_BOTTOM;

    } else if(avatar_screen_y < SCREEN_EDGE_TOP) {  // scroll up
      camera_y -= SCREEN_EDGE_TOP - avatar_screen_y;
      if(camera_y < 0) {  // unless the camera is at the top of the map
        camera_y = 0;
      } else {
        avatar_screen_y = SCREEN_EDGE_TOP;
      }
    }

    gfx_PrintInt(avatar_x, 3);
    gfx_PrintString(",");
    gfx_PrintInt(avatar_y, 3);
    gfx_PrintString(" scr:");
    gfx_PrintInt(avatar_screen_x, 3);
    gfx_PrintString(",");
    gfx_PrintInt(avatar_screen_y, 3);

    gfx_TransparentSprite(avatar, avatar_screen_x, avatar_screen_y);

    gfx_SwapDraw();

  } while(!kb_IsDown(kb_KeyEnter));

  gfx_End();
}

void DrawTilemap(gfx_tilemap_t* tilemap, uint24_t x_offset, uint24_t y_offset) {
  uint8_t x_start, y_start, x, y;

  // screen is 20 tiles wide, 15 tiles tall. if drawing partial tiles, it's max 21x16

  // offset / 16 gives the top left tile to use

  x_start = x_offset / 16;
  y_start = y_offset / 16;

  for(x = 0; x < 20; x++) {
    for(y = 0; y < 15; y++) {
      // this usage of x & y is wrong.
      // need to get the tile id at the tile of x_start PLUS current x
      // then draw it on the screen based on the remainder of x_offset / 16 (shifting up and left as necessary)
      uint8_t tile_id = tilemap->map[x + (y * tilemap->width)];
      gfx_sprite_t* tile_sprite = tilemap->tiles[tile_id];
      gfx_Sprite(tile_sprite, x, y);
    }
  }
}
