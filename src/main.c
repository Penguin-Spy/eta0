/* main.c Â© Penguin_Spy 2024
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 * This Source Code Form is "Incompatible With Secondary Licenses", as
 * defined by the Mozilla Public License, v. 2.0.
 *
 * The Covered Software may not be used as training or other input data
 * for LLMs, generative AI, or other forms of machine learning or neural
 * networks.
 */

#include <stdint.h>
#include <tice.h>
#include <keypadc.h>
#include <graphx.h>

// Include the sprite data - generated with `make gfx`
#include "gfx/gfx.h"

#define TILE_WIDTH          16
#define TILE_HEIGHT         16

#define TILEMAP_WIDTH       32
#define TILEMAP_HEIGHT      25

#define TILEMAP_DRAW_WIDTH  21
#define TILEMAP_DRAW_HEIGHT 15

#define Y_OFFSET            16
#define X_OFFSET            0

unsigned char tilemap_map[800] = {
    0x00,0x03,0x00,0x03,0x09,0x08,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,
    0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x11,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x02,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x00,0x01,0x01,0x00,0x00,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x02,0x02,0x02,0x00,0x02,0x00,0x00,0x01,
    0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
    0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,
    0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};


#define SCREEN_EDGE_LEFT 48
#define SCREEN_EDGE_TOP  48
#define SCREEN_EDGE_BOTTOM 192
#define SCREEN_EDGE_RIGHT 272

int main(void) {
  // DO NOT ASSIGN TO MANUALLY (i think).
  // signed integers to allow them to temporarily become negative while calculating avatar screen position
  int camera_x = 0, camera_y = 0;
  int camera_max_x, camera_max_y;
  gfx_tilemap_t tilemap;

  int avatar_x = 64;
  int avatar_y = 60;
  int avatar_vx = 0;
  int avatar_vy = 0;

  int avatar_screen_x = avatar_x;
  int avatar_screen_y = avatar_y;
  int avatar_x_prev = avatar_x, avatar_y_prev = avatar_y;

  // Initialize the tilemap structure
  tilemap.tiles       = tileset_tiles;      // the tileset graphics data
  tilemap.type_width  = gfx_tile_16_pixel;  // "tile type height"
  tilemap.type_height = gfx_tile_16_pixel;
  tilemap.tile_height = TILE_HEIGHT;        // "individual tile height" (distinction between this and type_height is unknown)
  tilemap.tile_width  = TILE_WIDTH;
  tilemap.draw_height = TILEMAP_DRAW_HEIGHT;  // size of area to draw
  tilemap.draw_width  = TILEMAP_DRAW_WIDTH;
  tilemap.y_loc       = Y_OFFSET;           // position on the screen to draw the tilemap
  tilemap.x_loc       = X_OFFSET;

  // this stuff will change from room to room (tilemap height & width may stay the same, or be used to determine room size. not sure)
  tilemap.map         = tilemap_map;        // the data to be shown (array of tile indicies)
  tilemap.height      = TILEMAP_HEIGHT;     // size of the tile map array
  tilemap.width       = TILEMAP_WIDTH;
  camera_max_x = (tilemap.width * TILE_WIDTH) - LCD_WIDTH;
  camera_max_y = (tilemap.height * TILE_HEIGHT) - LCD_HEIGHT;

  kb_SetMode(MODE_3_CONTINUOUS);

  gfx_Begin();

  // Set the palette
  gfx_SetPalette(global_palette, sizeof_global_palette, 0);
  gfx_SetColor(1);
  gfx_SetTextFGColor(2);
  gfx_SetTextBGColor(1);

  // Draw to buffer to avoid tearing
  gfx_SetDrawBuffer();

  // Set monospace font with width of 8
  gfx_SetMonospaceFont(8);

  do {
    uint8_t tile_id;
    uint16_t tile_x, tile_y;

    // Draw tilemap and coords
    // ? the no clipping version instantly crashes on a non-multiple-of-16 X offset, or quickly crashes with negative Y coord
    // ? the clipped version handles sub-tile X offsets, but corrupts heavily & crashes when displaying out of bounds Y coords. out of bounds X coords basically do nodraw
    gfx_Tilemap(&tilemap, camera_x, camera_y);
    gfx_FillRectangle(0, 0, 320, 16);
    gfx_SetTextXY(8, 4);
    /*gfx_PrintStringXY("x:", 8, 4);
    gfx_PrintInt(camera_x, 3);
    gfx_PrintString(" y:");
    gfx_PrintInt(camera_y, 3);
    gfx_PrintString(" pos:");*/

    /*block_mapped = *gfx_TilePtrMapped(&tilemap, x_offset / TILE_WIDTH, y_offset / TILE_HEIGHT);
    block_ptr = *gfx_TilePtr(&tilemap, x_offset, y_offset);

    gfx_PrintUInt(block_mapped, 3);
    gfx_PrintString("/");
    gfx_PrintUInt(block_ptr, 3);*/

    //while(!kb_IsDown(kb_Key2nd)) {};
    //while(kb_IsDown(kb_Key2nd)) {};


    // movement - input & velocity

    if(kb_IsDown(kb_KeyLeft) && avatar_vx > -8) {
      avatar_vx -= 1;
    } else if(kb_IsDown(kb_KeyRight) && avatar_vx < 8) {
      avatar_vx += 1;
    } else if(avatar_vx > 0) {
      avatar_vx -= 1;
    } else if(avatar_vx < 0) {
      avatar_vx += 1;
    }

    if(kb_IsDown(kb_KeyUp)) {
      avatar_vy = -8;
    }
#define FLOOR 64
    if(avatar_y + avatar_vy > FLOOR) {
      avatar_y = FLOOR;   // this breaks vertical positioning
      avatar_vy = 0;
    } else if(avatar_y < FLOOR && avatar_vy < 12) { // don't increase vy at y=FLOOR
      avatar_vy += 1;
    }

    // movement - sprite movement or screen scrolling

    // collision
    /*tile_x = (avatar_x + avatar_vx) / 16;
    tile_y = (avatar_y + avatar_vy) / 16;
    tile_id = tilemap.map[tile_x + (tile_y * tilemap.width)];
    if(tile_id == 0x01 || tile_id == 0x02) { // collides with wall
      if(avatar_vx > 0) { // moving right, hit left wall
        avatar_x = (tile_x - 1) * 16;
      } else {  // moving left, hit right wall
        avatar_x = (tile_x + 1) * 16;
      }
      avatar_vx = 0;
    } else { // didn't collide, can move
      avatar_x += avatar_vx;
    }*/
    tile_x = (avatar_x + avatar_vx) / 16;
    tile_y = (avatar_y + avatar_vy) / 16;
    tile_id = tilemap.map[tile_x + (tile_y * tilemap.width)];
    gfx_PrintString("id: ");
    gfx_PrintInt(tile_id, 3);

    avatar_x += avatar_vx;
    avatar_y += avatar_vy;

    // can't use vx & vy, need to actually track the difference in position to account for all the ways the avatar position can change
    avatar_screen_x += avatar_x - avatar_x_prev;
    avatar_screen_y += avatar_y - avatar_y_prev;   // screen 0,0 is top left, game 0,0 is bottom left
    avatar_x_prev = avatar_x;
    avatar_y_prev = avatar_y;

    // scroll visible area (camera) to keep avatar mostly in the center of the screen
    // but keep the visible area within the area where the tilemap is valid
    if(avatar_screen_x > SCREEN_EDGE_RIGHT) {     // 280 > 272  ;   280 - 272 = +8
      camera_x += avatar_screen_x - SCREEN_EDGE_RIGHT;  // camera_x + 8
      if(camera_x > camera_max_x) {     // camera_x = 198, max = 192;  extra = 6
        avatar_screen_x -= (avatar_screen_x - SCREEN_EDGE_RIGHT) + (camera_max_x - camera_x); // needs to move avatar left 6
        camera_x = camera_max_x;  // this scrolls the map left 6
      } else {
        avatar_screen_x = SCREEN_EDGE_RIGHT;
      }
    } else if(avatar_screen_x < SCREEN_EDGE_LEFT) {   // camera moving left, scroll level right
      camera_x -= SCREEN_EDGE_LEFT - avatar_screen_x;
      if(camera_x < 0) {    // unless the camera is at the left of the map
        // avatar needs to move on the screen right to account for the distance the camera could scroll
        avatar_screen_x += (SCREEN_EDGE_LEFT - avatar_screen_x) + camera_x;
        camera_x = 0;
      } else {  // if the camera could scroll all the way, move the avatar all the way back
        avatar_screen_x = SCREEN_EDGE_LEFT;
      }
    }
    if(avatar_screen_y > SCREEN_EDGE_BOTTOM) {
      camera_y += avatar_screen_y - SCREEN_EDGE_BOTTOM;
      avatar_screen_y = SCREEN_EDGE_BOTTOM;

    } else if(avatar_screen_y < SCREEN_EDGE_TOP) {  // scroll up
      camera_y -= SCREEN_EDGE_TOP - avatar_screen_y;
      if(camera_y < 0) {  // unless the camera is at the top of the map
        camera_y = 0;
      } else {
        avatar_screen_y = SCREEN_EDGE_TOP;
      }
    }

    gfx_PrintInt(avatar_x, 3);
    gfx_PrintString(",");
    gfx_PrintInt(avatar_y, 3);
    gfx_PrintString(" scr:");
    gfx_PrintInt(avatar_screen_x, 3);
    gfx_PrintString(",");
    gfx_PrintInt(avatar_screen_y, 3);

    gfx_TransparentSprite(avatar, avatar_screen_x, avatar_screen_y);

    gfx_SwapDraw();

  } while(!kb_IsDown(kb_KeyEnter));

  gfx_End();
}
